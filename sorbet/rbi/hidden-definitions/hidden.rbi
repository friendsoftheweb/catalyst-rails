# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  def any_templates?(*_, &_1); end

  def formats(*_, &_1); end

  def initialize(lookup_context); end

  def render(); end

  def template_exists?(*_, &_1); end
  NO_DETAILS = ::T.let(nil, ::T.untyped)
end

module ActionView::AbstractRenderer::ObjectRendering
  def initialize(lookup_context, options); end
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

module ActionView::AbstractRenderer::ObjectRendering
end

class ActionView::AbstractRenderer::RenderedCollection
  def body(); end

  def format(); end

  def initialize(rendered_templates, spacer); end

  def rendered_templates(); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
  def body(); end

  def format(); end

  def initialize(format); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
end

class ActionView::AbstractRenderer::RenderedCollection
  def self.empty(format); end
end

class ActionView::AbstractRenderer::RenderedTemplate
  def body(); end

  def format(); end

  def initialize(body, template); end

  def template(); end
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedTemplate
end

class ActionView::AbstractRenderer
end

class ActionView::Base
  def annotate_rendered_view_with_filenames(); end

  def annotate_rendered_view_with_filenames=(val); end

  def prefix_partial_path_with_controller_namespace?(); end
end

class ActionView::Base
  def self.annotate_rendered_view_with_filenames(); end

  def self.annotate_rendered_view_with_filenames=(val); end

  def self.prefix_partial_path_with_controller_namespace?(); end
end

class ActionView::CacheExpiry
  def clear_cache(); end

  def clear_cache_if_necessary(); end

  def initialize(watcher:); end
end

class ActionView::CacheExpiry::Executor
  def before(target); end

  def initialize(watcher:); end
end

class ActionView::CacheExpiry::Executor
end

class ActionView::CacheExpiry
end

module ActionView::CollectionCaching
end

module ActionView::CollectionCaching
  extend ::ActiveSupport::Concern
end

class ActionView::CollectionRenderer
  include ::ActionView::AbstractRenderer::ObjectRendering
  def render_collection_derive_partial(collection, context, block); end

  def render_collection_with_partial(collection, partial, context, block); end
end

class ActionView::CollectionRenderer::CollectionIterator
  include ::Enumerable
  def each(&blk); end

  def initialize(collection); end

  def size(); end
end

class ActionView::CollectionRenderer::CollectionIterator
end

class ActionView::CollectionRenderer::MixedCollectionIterator
  def each_with_info(); end

  def initialize(collection, paths); end
end

class ActionView::CollectionRenderer::MixedCollectionIterator
end

class ActionView::CollectionRenderer::PreloadCollectionIterator
  def initialize(collection, path, variables, relation); end
end

class ActionView::CollectionRenderer::PreloadCollectionIterator
end

class ActionView::CollectionRenderer::SameCollectionIterator
  def each_with_info(); end

  def from_collection(collection); end

  def initialize(collection, path, variables); end
end

class ActionView::CollectionRenderer::SameCollectionIterator
end

class ActionView::CollectionRenderer
end

class ActionView::Digestor
end

class ActionView::Digestor::Injected
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Injected
end

class ActionView::Digestor::Missing
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Missing
end

class ActionView::Digestor::Node
  def children(); end

  def dependency_digest(finder, stack); end

  def digest(finder, stack=T.unsafe(nil)); end

  def initialize(name, logical_name, template, children=T.unsafe(nil)); end

  def logical_name(); end

  def name(); end

  def template(); end

  def to_dep_map(); end
end

class ActionView::Digestor::Node
  def self.create(name, logical_name, template, partial); end
end

class ActionView::Digestor::NullLogger
end

class ActionView::Digestor::NullLogger
  def self.debug(_); end

  def self.error(_); end
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor
  def self.digest(name:, finder:, format: T.unsafe(nil), dependencies: T.unsafe(nil)); end

  def self.logger(); end

  def self.tree(name, finder, partial=T.unsafe(nil), seen=T.unsafe(nil)); end
end

class ActionView::FallbackFileSystemResolver
  def build_unbound_template(template, _); end
end

class ActionView::FallbackFileSystemResolver
  def self.instances(); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path); end

  def path(); end

  def to_path(); end
end

class ActionView::FileSystemResolver
end

module ActionView::Helpers::TagHelper
  def class_names(*args); end

  def token_list(*args); end
  ARIA_PREFIXES = ::T.let(nil, ::T.untyped)
  DATA_PREFIXES = ::T.let(nil, ::T.untyped)
  TAG_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  def self.build_tag_values(*args); end
end

module ActionView::Helpers::TranslationHelper
  def self.i18n_option?(name); end
end

module ActionView::Helpers::UrlHelper
  def phone_to(phone_number, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def sms_to(phone_number, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
end

module ActionView::Helpers
  extend ::ActiveSupport::Autoload
end

module ActionView::Layouts::ClassMethods::LayoutConditions
end

module ActionView::Layouts::ClassMethods::LayoutConditions
end

class ActionView::LookupContext
  include ::ActionView::LookupContext::Accessors
  include ::ActionView::LookupContext::DetailsCache
  include ::ActionView::LookupContext::ViewPaths
  def digest_cache(); end

  def fallbacks(); end

  def fallbacks=(val); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def registered_details(); end

  def registered_details=(val); end

  def rendered_format(); end

  def rendered_format=(rendered_format); end

  def with_prepended_formats(formats); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
end

module ActionView::LookupContext::DetailsCache
  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

module ActionView::LookupContext::DetailsCache
end

class ActionView::LookupContext::DetailsKey
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.details_cache_key(details); end

  def self.digest_cache(details); end

  def self.digest_caches(); end

  def self.view_context_class(klass); end
end

module ActionView::LookupContext::ViewPaths
  def any?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def any_templates?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def view_paths(); end

  def with_fallbacks(); end
end

module ActionView::LookupContext::ViewPaths
end

class ActionView::LookupContext
  def self.fallbacks(); end

  def self.fallbacks=(val); end

  def self.register_detail(name, &block); end

  def self.registered_details(); end

  def self.registered_details=(val); end
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *_); end
end

class ActionView::ObjectRenderer
  include ::ActionView::AbstractRenderer::ObjectRendering
  def render_object_derive_partial(object, context, block); end

  def render_object_with_partial(object, partial, context, block); end
end

class ActionView::ObjectRenderer
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*_); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialRenderer
  include ::ActionView::CollectionCaching
  def collection_cache(); end

  def collection_cache=(val); end

  def initialize(lookup_context, options); end

  def render(partial, context, block); end
end

class ActionView::PartialRenderer
  def self.collection_cache(); end

  def self.collection_cache=(val); end
end

class ActionView::PathResolver
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
end

class ActionView::PathSet
  include ::Enumerable
  def +(array); end

  def <<(*args); end

  def [](*_, &_1); end

  def compact(); end

  def concat(*args); end

  def each(*_, &_1); end

  def exists?(path, prefixes, *args); end

  def find(*args); end

  def find_all(path, prefixes=T.unsafe(nil), *args); end

  def find_all_with_query(query); end

  def include?(*_, &_1); end

  def initialize(paths=T.unsafe(nil)); end

  def insert(*args); end

  def paths(); end

  def pop(*_, &_1); end

  def push(*args); end

  def size(*_, &_1); end

  def to_ary(); end

  def unshift(*args); end
end

class ActionView::PathSet
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_partial_to_object(context, options, &block); end

  def render_template(context, options); end

  def render_template_to_object(context, options); end

  def render_to_object(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def initialize(); end

  def process(*_); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_renderer(); end
end

module ActionView::Rendering::ClassMethods
  def _helpers(); end

  def _routes(); end

  def build_view_context_class(klass, supports_path, routes, helpers); end

  def view_context_class(); end
end

module ActionView::Rendering
  extend ::ActiveSupport::Concern
end

class ActionView::Resolver
  def caching(); end

  def caching=(val); end

  def caching?(*_, &_1); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_all_with_query(query); end
end

class ActionView::Resolver::Cache
  def cache(key, name, prefix, partial, locals); end

  def cache_query(query); end

  def clear(); end

  def size(); end
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

class ActionView::Resolver::Cache::SmallCache
  def initialize(options=T.unsafe(nil)); end
end

class ActionView::Resolver::Cache::SmallCache
end

class ActionView::Resolver::Cache
end

class ActionView::Resolver::Path
  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end
end

class ActionView::Resolver::Path
  def self.build(name, prefix, partial); end
end

class ActionView::Resolver::PathParser
  def build_path_regex(); end

  def parse(path); end
end

class ActionView::Resolver::PathParser
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(val); end

  def self.caching?(); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(view, template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::SyntaxErrorInTemplate
  def initialize(template, offending_code_string); end
end

class ActionView::Template
  def encode!(); end

  def format(); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, locals:, format: T.unsafe(nil), variant: T.unsafe(nil), virtual_path: T.unsafe(nil)); end

  def locals(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def render(view, locals, buffer=T.unsafe(nil), add_to_stack: T.unsafe(nil), &block); end

  def short_identifier(); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def variable(); end

  def variant(); end

  def virtual_path(); end
end

class ActionView::Template::Error
  def annotated_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::HTML
  def format(); end

  def identifier(); end

  def initialize(string, type); end

  def render(*args); end

  def to_str(); end

  def type(); end
end

class ActionView::Template::HTML
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template, source); end

  def default_format(); end

  def default_format=(default_format); end

  def default_format?(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(value); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template, source); end

  def erb_implementation(); end

  def erb_implementation=(erb_implementation); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(erb_trim_mode); end

  def erb_trim_mode?(); end

  def escape_ignore_list(); end

  def escape_ignore_list=(escape_ignore_list); end

  def escape_ignore_list?(); end

  def handles_encoding?(); end

  def supports_streaming?(); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  def evaluate(action_view_erb_handler_context); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
end

class ActionView::Template::Handlers::ERB
  def self.call(template, source); end

  def self.erb_implementation(); end

  def self.erb_implementation=(value); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(value); end

  def self.erb_trim_mode?(); end

  def self.escape_ignore_list(); end

  def self.escape_ignore_list=(value); end

  def self.escape_ignore_list?(); end
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Raw
  def call(template, source); end
end

class ActionView::Template::Handlers::Raw
end

module ActionView::Template::Handlers
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Inline
end

class ActionView::Template::RawFile
  def format(); end

  def format=(format); end

  def identifier(); end

  def initialize(filename); end

  def render(*args); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::RawFile
end

class ActionView::Template::Renderable
  def format(); end

  def identifier(); end

  def initialize(renderable); end

  def render(context, *args); end
end

class ActionView::Template::Renderable
end

module ActionView::Template::Sources
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

module ActionView::Template::Sources
  extend ::ActiveSupport::Autoload
end

class ActionView::Template::Text
  def format(); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Text
end

class ActionView::Template::Types
  def type_klass(); end

  def type_klass=(val); end
end

class ActionView::Template::Types::Type
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_str(); end

  def to_sym(); end
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Types::Type
  def self.[](type); end
end

class ActionView::Template::Types
  def self.[](type); end

  def self.delegate_to(klass); end

  def self.symbols(); end

  def self.type_klass(); end

  def self.type_klass=(val); end
end

class ActionView::Template
  extend ::ActiveSupport::Autoload
  extend ::ActionView::Template::Handlers
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::UnboundTemplate
  def bind_locals(locals); end

  def initialize(source, identifier, handler, options); end
end

class ActionView::UnboundTemplate
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
end

module ActionView::ViewPaths
  def _prefixes(); end

  def any_templates?(*_, &_1); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*_, &_1); end

  def formats=(arg); end

  def locale(*_, &_1); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*_, &_1); end

  def view_paths(*_, &_1); end
end

module ActionView::ViewPaths::ClassMethods
  def _prefixes(); end

  def _view_paths(); end

  def _view_paths=(paths); end

  def prepend_view_path(path); end

  def view_paths(); end

  def view_paths=(paths); end
end

module ActionView::ViewPaths
  extend ::ActiveSupport::Concern
  def self.all_view_paths(); end

  def self.get_view_paths(klass); end

  def self.set_view_paths(klass, paths); end
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActionView
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(val); end

  def test_order(); end

  def test_order=(val); end
end

module ActiveSupport::ActionableError
end

module ActiveSupport::ActionableError::ClassMethods
  def action(name, &block); end
end

module ActiveSupport::ActionableError::ClassMethods
end

class ActiveSupport::ActionableError::NonActionable
end

class ActiveSupport::ActionableError::NonActionable
end

module ActiveSupport::ActionableError
  extend ::ActiveSupport::Concern
  def self.actions(error); end

  def self.dispatch(error, name); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
  def bytesize(); end

  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), **_); end

  def mismatched?(version); end

  def value(); end

  def version(); end
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
end

ActiveSupport::Cache::MemoryStore::DEFAULT_CODER = ActiveSupport::Cache::MemoryStore::DupCoder

module ActiveSupport::Cache::MemoryStore::DupCoder
end

module ActiveSupport::Cache::MemoryStore::DupCoder
  def self.dump(entry); end

  def self.load(entry); end
end

module ActiveSupport::Cache::NullCoder
end

module ActiveSupport::Cache::NullCoder
  def self.dump(entry); end

  def self.load(payload); end
end

class ActiveSupport::Cache::Store
  def delete_multi(names, options=T.unsafe(nil)); end
end

ActiveSupport::Cache::Store::DEFAULT_CODER = Marshal

module ActiveSupport::Cache::Strategy::LocalCache
  def delete_matched(matcher, options=T.unsafe(nil)); end
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.lookup_store(store=T.unsafe(nil), *parameters); end
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Callbacks::CallTemplate
  def expand(target, value, block); end

  def initialize(target, method, arguments, block); end

  def inverted_lambda(); end

  def make_lambda(); end
end

class ActiveSupport::Callbacks::CallTemplate
  def self.build(filter, callback); end
end

class ActiveSupport::Callbacks::Callback
  def apply(callback_sequence); end

  def chain_config(); end

  def current_scopes(); end

  def duplicates?(other); end

  def filter(); end

  def initialize(name, filter, kind, options, chain_config); end

  def kind(); end

  def kind=(kind); end

  def matches?(_kind, _filter); end

  def merge_conditional_options(chain, if_option:, unless_option:); end

  def name(); end

  def name=(name); end

  def raw_filter(); end
end

class ActiveSupport::Callbacks::Callback
  def self.build(chain, filter, kind, options); end
end

class ActiveSupport::Callbacks::CallbackChain
  include ::Enumerable
  def append(*callbacks); end

  def chain(); end

  def clear(); end

  def compile(); end

  def config(); end

  def delete(o); end

  def each(&block); end

  def empty?(); end

  def index(o); end

  def initialize(name, config); end

  def insert(index, o); end

  def name(); end

  def prepend(*callbacks); end
end

class ActiveSupport::Callbacks::CallbackChain
end

class ActiveSupport::Callbacks::CallbackSequence
  def after(&after); end

  def around(call_template, user_conditions); end

  def before(&before); end

  def expand_call_template(arg, block); end

  def final?(); end

  def initialize(nested=T.unsafe(nil), call_template=T.unsafe(nil), user_conditions=T.unsafe(nil)); end

  def invoke_after(arg); end

  def invoke_before(arg); end

  def nested(); end

  def skip?(arg); end
end

class ActiveSupport::Callbacks::CallbackSequence
end

module ActiveSupport::Callbacks::Conditionals
end

class ActiveSupport::Callbacks::Conditionals::Value
  def call(target, value); end

  def initialize(&block); end
end

class ActiveSupport::Callbacks::Conditionals::Value
end

module ActiveSupport::Callbacks::Conditionals
end

module ActiveSupport::Callbacks::Filters
end

class ActiveSupport::Callbacks::Filters::After
end

class ActiveSupport::Callbacks::Filters::After
  def self.build(callback_sequence, user_callback, user_conditions, chain_config); end
end

class ActiveSupport::Callbacks::Filters::Before
end

class ActiveSupport::Callbacks::Filters::Before
  def self.build(callback_sequence, user_callback, user_conditions, chain_config, filter, name); end
end

class ActiveSupport::Callbacks::Filters::Environment
  def halted(); end

  def halted=(_); end

  def target(); end

  def target=(_); end

  def value(); end

  def value=(_); end
end

class ActiveSupport::Callbacks::Filters::Environment
  def self.[](*_); end

  def self.members(); end
end

module ActiveSupport::Callbacks::Filters
end

module ActiveSupport::Concern
  def prepend_features(base); end

  def prepended(base=T.unsafe(nil), &block); end
end

class ActiveSupport::Concern::MultiplePrependBlocks
  def initialize(); end
end

class ActiveSupport::Concern::MultiplePrependBlocks
end

class ActiveSupport::ConfigurationFile
  def initialize(content_path); end

  def parse(context: T.unsafe(nil), **options); end
end

class ActiveSupport::ConfigurationFile::FormatError
end

class ActiveSupport::ConfigurationFile::FormatError
end

class ActiveSupport::ConfigurationFile
  def self.parse(content_path, **options); end
end

class ActiveSupport::CurrentAttributes
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.after_reset(&block); end

  def self.attribute(*names); end

  def self.before_reset(&block); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*_, &_1); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*_, &_1); end
end

module ActiveSupport::Dependencies
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies::Blamable
  def blame_file!(file); end

  def blamed_files(); end

  def copy_blame!(exc); end

  def describe_blame(); end
end

module ActiveSupport::Dependencies::Blamable
end

class ActiveSupport::Dependencies::ClassCache
  def [](key); end

  def clear!(); end

  def empty?(); end

  def get(key); end

  def key?(key); end

  def safe_get(key); end

  def store(klass); end
end

class ActiveSupport::Dependencies::ClassCache
end

class ActiveSupport::Dependencies::Interlock
  def done_running(); end

  def done_unloading(); end

  def loading(); end

  def permit_concurrent_loads(); end

  def raw_state(&block); end

  def running(); end

  def start_running(); end

  def start_unloading(); end

  def unloading(); end
end

class ActiveSupport::Dependencies::Interlock
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def const_missing(const_name); end

  def guess_for_anonymous(const_name); end

  def unloadable(const_desc=T.unsafe(nil)); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def self.append_features(base); end

  def self.exclude_from(base); end

  def self.include_into(base); end
end

class ActiveSupport::Dependencies::WatchStack
  include ::Enumerable
  def each(&block); end

  def new_constants(); end

  def watch_namespaces(namespaces); end

  def watching(); end

  def watching?(); end
end

class ActiveSupport::Dependencies::WatchStack
end

class ActiveSupport::Deprecation
  include ::ActiveSupport::Deprecation::Disallowed
end

module ActiveSupport::Deprecation::Behavior
  def disallowed_behavior(); end

  def disallowed_behavior=(behavior); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def respond_to?(*_, &_1); end
end

module ActiveSupport::Deprecation::Disallowed
  def disallowed_warnings(); end

  def disallowed_warnings=(disallowed_warnings); end
end

module ActiveSupport::Deprecation::Disallowed
end

module ActiveSupport::Deprecation::Reporting
  def allow(allowed_warnings=T.unsafe(nil), if: T.unsafe(nil), &block); end
end

class ActiveSupport::Deprecation
  def self.allow(*_, &_1); end

  def self.deprecation_warning(*_, &_1); end

  def self.disallowed_behavior(*_, &_1); end

  def self.disallowed_behavior=(arg); end

  def self.disallowed_warnings(*_, &_1); end

  def self.disallowed_warnings=(arg); end

  def self.initialize(*_, &_1); end

  def self.warn(*_, &_1); end
end

module ActiveSupport::DescendantsTracker
  def subclasses(); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
  include ::Enumerable
  def <<(klass); end

  def cleanup!(); end

  def each(&blk); end

  def refs_size(); end

  def reject!(); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
end

module ActiveSupport::DescendantsTracker
  def self.subclasses(klass); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  def +@(); end

  def -@(); end

  def after(time=T.unsafe(nil)); end

  def before(time=T.unsafe(nil)); end

  def coerce(other); end

  def encode_with(coder); end

  def in_days(); end

  def in_hours(); end

  def in_minutes(); end

  def in_months(); end

  def in_seconds(); end

  def in_weeks(); end

  def in_years(); end

  def init_with(coder); end

  def initialize(value, parts); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def parts(); end

  def parts=(parts); end

  def since(time=T.unsafe(nil)); end

  def until(time=T.unsafe(nil)); end

  def value=(value); end
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::Duration::Scalar
  def %(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def coerce(other); end

  def initialize(value); end

  def to_f(*_, &_1); end

  def to_i(*_, &_1); end

  def to_s(*_, &_1); end

  def value(); end
end

class ActiveSupport::Duration::Scalar
end

class ActiveSupport::Duration
  def self.===(other); end

  def self.days(value); end

  def self.hours(value); end

  def self.minutes(value); end

  def self.months(value); end

  def self.seconds(value); end

  def self.weeks(value); end

  def self.years(value); end
end

class ActiveSupport::EnvironmentInquirer
  def development?(); end

  def initialize(env); end

  def production?(); end

  def test?(); end
  DEFAULT_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EnvironmentInquirer
end

class ActiveSupport::ExecutionWrapper
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::Executor
end

class ActiveSupport::Executor
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::FileUpdateChecker
end

module ActiveSupport::ForkTracker
end

module ActiveSupport::ForkTracker::CoreExt
  def fork(*_); end
end

module ActiveSupport::ForkTracker::CoreExt
end

module ActiveSupport::ForkTracker::CoreExtPrivate
  include ::ActiveSupport::ForkTracker::CoreExt
end

module ActiveSupport::ForkTracker::CoreExtPrivate
end

module ActiveSupport::ForkTracker
  def self.after_fork(&block); end

  def self.check!(); end

  def self.hook!(); end

  def self.unregister(callback); end
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

module ActiveSupport::Inflector
  ALLOWED_ENCODINGS_FOR_TRANSLITERATE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Inflector::Inflections
  def acronym(word); end

  def acronyms(); end

  def acronyms_camelize_regex(); end

  def acronyms_underscore_regex(); end

  def clear(scope=T.unsafe(nil)); end

  def human(rule, replacement); end

  def humans(); end

  def irregular(singular, plural); end

  def plural(rule, replacement); end

  def plurals(); end

  def singular(rule, replacement); end

  def singulars(); end

  def uncountable(*words); end

  def uncountables(); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
  def <<(*word); end

  def add(words); end

  def delete(entry); end

  def initialize(); end

  def uncountable?(str); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
end

class ActiveSupport::Inflector::Inflections
  def self.instance(locale=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options=T.unsafe(nil), &block); end

  def run_load_hooks(name, base=T.unsafe(nil)); end
end

module ActiveSupport::LazyLoadHooks
  def self.extended(base); end
end

module ActiveSupport::LoggerThreadSafeLevel
  def log_at(level); end
end

class ActiveSupport::Multibyte::Chars
  def match?(*_, &_1); end
end

class ActiveSupport::Notifications::Event
  def payload=(payload); end
end

class ActiveSupport::Notifications::Fanout
  include ::Mutex_m
  def finish(name, id, payload, listeners=T.unsafe(nil)); end

  def initialize(); end

  def listeners_for(name); end

  def listening?(name); end

  def lock(); end

  def locked?(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), callable=T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def finish(name, id, payload); end

  def initialize(delegate); end

  def matches?(_); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(*_); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end

  def initialize(pattern, delegate); end

  def matches?(name); end

  def pattern(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end

  def exclusions(); end

  def initialize(pattern); end

  def pattern(); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def self.wrap(pattern); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed
end

class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  def self.new(pattern, listener, monotonic); end

  def self.wrap_all(pattern, subscriber); end
end

class ActiveSupport::Notifications::Fanout
end

class ActiveSupport::Notifications::InstrumentationRegistry
  def instrumenter_for(notifier); end
end

class ActiveSupport::Notifications::InstrumentationRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveSupport::Notifications::Instrumenter
  def finish(name, payload); end

  def finish_with_state(listeners_state, name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  def self.monotonic_subscribe(pattern=T.unsafe(nil), callback=T.unsafe(nil), &block); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(namespace); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(validate_float); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(value); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(value); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def nested_under_indifferent_access(); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(_); end

  def method_missing(name, *args); end
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def *(*_); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def []=(*args); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def delete_prefix(*args, &block); end

  def delete_prefix!(*args); end

  def delete_suffix(*args, &block); end

  def delete_suffix!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args, &block); end

  def insert(index, value); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def replace(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def scrub(*args, &block); end

  def scrub!(*args); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args, &block); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def unicode_normalize(*args, &block); end

  def unicode_normalize!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
end

class ActiveSupport::SecureCompareRotator
  include ::ActiveSupport::SecurityUtils
  include ::ActiveSupport::Messages::Rotator
  def secure_compare!(other_value, on_rotation: T.unsafe(nil)); end
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator
end

class ActiveSupport::SubscriberQueueRegistry
  def get_queue(queue_key); end
end

class ActiveSupport::SubscriberQueueRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveSupport::TaggedLogging::LocalTagStorage
  def current_tags(); end

  def current_tags=(current_tags); end
end

module ActiveSupport::TaggedLogging::LocalTagStorage
  def self.extended(base); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

class ActiveSupport::TestCase::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
end

class ActiveSupport::TestCase::Assertion
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end

  def unfreeze_time(); end
end

module ActiveSupport::Testing::TimeHelpers
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable
  def acts_like_time?(); end

  def after?(_); end

  def before?(_); end

  def comparable_time(); end

  def encode_with(coder); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmt?(); end

  def gmt_offset(); end

  def gmtime(); end

  def gmtoff(); end

  def in(other); end

  def init_with(coder); end

  def initialize(utc_time, time_zone, local_time=T.unsafe(nil), period=T.unsafe(nil)); end

  def is_a?(klass); end

  def isdst(); end

  def iso8601(fraction_digits=T.unsafe(nil)); end

  def kind_of?(klass); end

  def marshal_dump(); end

  def marshal_load(variables); end

  def method_missing(sym, *args, &block); end

  def next_day?(); end

  def prev_day?(); end

  def respond_to?(sym, include_priv=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def rfc822(); end

  def since(other); end

  def time_zone(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def tomorrow?(); end

  def tv_sec(); end

  def yesterday?(); end
  PRECISIONS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  include ::Comparable
  def =~(re); end

  def at(*args); end

  def encode_with(coder); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(name, utc_offset=T.unsafe(nil), tzinfo=T.unsafe(nil)); end

  def iso8601(str); end

  def local_to_utc(time, dst=T.unsafe(nil)); end

  def match?(re); end

  def name(); end

  def parse(str, now=T.unsafe(nil)); end

  def period_for_local(time, dst=T.unsafe(nil)); end

  def period_for_utc(time); end

  def periods_for_local(time); end

  def rfc3339(str); end

  def strptime(str, format, now=T.unsafe(nil)); end

  def tzinfo(); end

  def utc_offset(); end

  def utc_to_local(time); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  def self.clear(); end

  def self.create(*_); end

  def self.find_tzinfo(name); end

  def self.new(name); end

  def self.seconds_to_utc_offset(seconds, colon=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport::Tryable
  def try(method_name=T.unsafe(nil), *args, &b); end

  def try!(method_name=T.unsafe(nil), *args, &b); end
end

module ActiveSupport::Tryable
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*_, &_1); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport::XmlMini_REXML
  def parse(data); end
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  extend ::ActiveSupport::XmlMini_REXML
end

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  extend ::ActiveSupport::Autoload
  def self.escape_html_entities_in_json(*_, &_1); end

  def self.escape_html_entities_in_json=(arg); end

  def self.gem_version(); end

  def self.json_encoder(*_, &_1); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(val); end

  def self.test_order(); end

  def self.test_order=(val); end

  def self.time_precision(*_, &_1); end

  def self.time_precision=(arg); end

  def self.to_time_preserves_timezone(); end

  def self.to_time_preserves_timezone=(value); end

  def self.use_standard_json_time_format(*_, &_1); end

  def self.use_standard_json_time_format=(arg); end

  def self.utc_to_local_returns_utc_offset_times(); end

  def self.utc_to_local_returns_utc_offset_times=(value); end

  def self.version(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def compact_blank!(); end

  def deconstruct(); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  def clone(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(_); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Catalyst::Config
  def self.context_path(*args, &block); end
end

module Catalyst::Helpers
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::ActiveSupport::ForkTracker::CoreExt
end

module Catalyst::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Catalyst::Manifest
  def self.[](*args, &block); end

  def self.has?(*args, &block); end

  def self.prefetch_urls_for(*args, &block); end

  def self.preload_urls_for(*args, &block); end
end

module Catalyst
  extend ::Dry::Configurable::ClassMethods
  extend ::Dry::Configurable::Methods
end

class Class
  def class_attribute(*attrs, instance_accessor: T.unsafe(nil), instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_predicate: T.unsafe(nil), default: T.unsafe(nil)); end

  def descendants(); end

  def json_creatable?(); end

  def subclasses(); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

class Date
  include ::DateAndTime::Zones
  def acts_like_date?(); end

  def ago(seconds); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def default_inspect(); end

  def in(seconds); end

  def infinite?(); end

  def minus_with_duration(other); end

  def minus_without_duration(_); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def readable_inspect(); end

  def since(seconds); end

  def to_default_s(); end
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date
  def self.beginning_of_week(); end

  def self.beginning_of_week=(week_start); end

  def self.beginning_of_week_default(); end

  def self.beginning_of_week_default=(beginning_of_week_default); end

  def self.find_beginning_of_week!(week_start); end
end

module DateAndTime::Calculations
  def next_day?(); end

  def prev_day?(); end

  def tomorrow?(); end

  def yesterday?(); end
end

module DateAndTime::Compatibility
  def preserve_timezone(); end

  def utc_to_local_returns_utc_offset_times(); end
end

module DateAndTime::Compatibility
  def self.preserve_timezone(); end

  def self.preserve_timezone=(val); end

  def self.utc_to_local_returns_utc_offset_times(); end

  def self.utc_to_local_returns_utc_offset_times=(val); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
end

class DateTime
  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end
end

class Delegator
  include ::ActiveSupport::Tryable
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::CorrectElement
  def call(names, element); end
end

class DidYouMean::CorrectElement
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::ParseDimensions
  def call(); end

  def initialize(dictionary, separator); end
end

class DidYouMean::ParseDimensions
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dimensions(); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def separator(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.exists?(_); end
end

module Dry::Configurable
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::DSL
  VALID_NAME = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::Setting
  CLONABLE_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  DEFAULT_CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Dry::Configurable::Setting::Nested
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
end

module Dry::Core::Constants
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  EMPTY_OPTS = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  Self = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end
end

class Encoding
  def _dump(*_); end
  CESU_8 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def chain(*_); end

  def compact_blank(); end

  def excluding(*elements); end

  def including(*elements); end

  def pick(*keys); end

  def sum(identity=T.unsafe(nil), &block); end

  def without(*elements); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def eager(); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Erubi::Engine
  def bufvar(); end

  def filename(); end

  def initialize(input, properties=T.unsafe(nil)); end

  def src(); end
end

class Erubi::Engine
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def initialize(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end
end

class File
  def self.absolute_path?(_); end

  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.exists?(_); end

  def self.probe_stat_in(dir); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
  def receiver(); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::Dependency
  def pretty_print(q); end
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::List
  def pretty_print(q); end
end

class Gem::Package
  def gem(); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher::FetchError
  include ::Gem::UriParsing
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::RequestSet
  def pretty_print(q); end
end

class Gem::Requirement
  def pretty_print(q); end
end

class Gem::Resolver::APISet
  def pretty_print(q); end
end

class Gem::Resolver::APISpecification
  def pretty_print(q); end
end

class Gem::Resolver::ActivationRequest
  def pretty_print(q); end
end

class Gem::Resolver::BestSet
  def pretty_print(q); end
end

class Gem::Resolver::Conflict
  def pretty_print(q); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::DependencyRequest
  def pretty_print(q); end
end

class Gem::Resolver::GitSet
  def pretty_print(q); end
end

class Gem::Resolver::GitSpecification
  def pretty_print(q); end
end

class Gem::Resolver::IndexSet
  def pretty_print(q); end
end

class Gem::Resolver::IndexSpecification
  def pretty_print(q); end
end

class Gem::Resolver::InstalledSpecification
  def pretty_print(q); end
end

class Gem::Resolver::InstallerSet
  def pretty_print(q); end
end

class Gem::Resolver::LocalSpecification
  def pretty_print(q); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LockSet
  def pretty_print(q); end
end

class Gem::Resolver::LockSpecification
  def pretty_print(q); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::VendorSet
  def pretty_print(q); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

class Gem::Security::KEY_ALGORITHM
  def d(); end

  def dmp1(); end

  def dmq1(); end

  def e(); end

  def export(*_); end

  def initialize(*_); end

  def iqmp(); end

  def n(); end

  def p(); end

  def params(); end

  def private?(); end

  def private_decrypt(*_); end

  def private_encrypt(*_); end

  def public?(); end

  def public_decrypt(*_); end

  def public_encrypt(*_); end

  def public_key(); end

  def q(); end

  def set_crt_params(_, _1, _2); end

  def set_factors(_, _1); end

  def set_key(_, _1, _2); end

  def sign_pss(*_); end

  def to_der(); end

  def to_pem(*_); end

  def to_s(*_); end

  def to_text(); end

  def verify_pss(*_); end
  NO_PADDING = ::T.let(nil, ::T.untyped)
  PKCS1_OAEP_PADDING = ::T.let(nil, ::T.untyped)
  PKCS1_PADDING = ::T.let(nil, ::T.untyped)
  SSLV23_PADDING = ::T.let(nil, ::T.untyped)
end

class Gem::Security::KEY_ALGORITHM
  def self.generate(*_); end
end

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::Source
  def pretty_print(q); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def pretty_print(q); end

  def removed_method_calls(); end

  def to_ruby(); end
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

class Gem::Version
  def pretty_print(q); end
end

Gem::Version::Requirement = Gem::Requirement

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def assert_valid_keys(*valid_keys); end

  def compact_blank!(); end

  def deconstruct_keys(_); end

  def deep_merge!(other_hash, &block); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def slice!(*keys); end

  def to_options!(); end

  def to_param(namespace=T.unsafe(nil)); end
end

class Hash
  def self.ruby2_keywords_hash(_); end

  def self.ruby2_keywords_hash?(_); end

  def self.try_convert(_); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

module I18n::Backend::Fallbacks
  def exists?(locale, key, options=T.unsafe(nil)); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

class IO
  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def ready?(); end

  def set_encoding_by_bom(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::ActiveSupport::ForkTracker::CoreExt
  def itself(); end

  def object_id(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end

  def self.fork(); end

  def self.load(*_); end

  def self.require(_); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class LoadError
  def is_missing?(location); end
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_IMPORTANT = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def _synchronize(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Test
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  def capture_exceptions(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Module
  include ::Module::Concerning
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  def alias_attribute(new_name, old_name); end

  def anonymous?(); end

  def attr_internal(*attrs); end

  def attr_internal_accessor(*attrs); end

  def attr_internal_reader(*attrs); end

  def attr_internal_writer(*attrs); end

  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  def delegate_missing_to(target, allow_nil: T.unsafe(nil)); end

  def deprecate(*method_names); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), location: T.unsafe(nil)); end

  def method_visibility(method); end

  def module_parent(); end

  def module_parent_name(); end

  def module_parents(); end

  def redefine_method(method, &block); end

  def redefine_singleton_method(method, &block); end

  def remove_possible_method(method); end

  def remove_possible_singleton_method(method); end

  def silence_redefinition_of_method(method); end

  def thread_cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def thread_mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  def concern(topic, &module_definition); end

  def concerning(topic, prepend: T.unsafe(nil), &block); end
end

module Module::Concerning
end

class Module::DelegationError
end

class Module::DelegationError
end

class Module
  def self.attr_internal_naming_format(); end

  def self.attr_internal_naming_format=(attr_internal_naming_format); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(_, _1); end
end

module MonitorMixin
  def initialize(*args); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
  def missing_name(); end

  def missing_name?(name); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_d(); end
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::ElementDescription
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Tryable
  include ::ActiveSupport::Dependencies::Loadable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::ActiveSupport::ForkTracker::CoreExt
  def html_safe?(); end

  def presence_in(another_object); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenStruct
  VERSION = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

module Process
  def self.fork(); end
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extentions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  VERSION = ::T.let(nil, ::T.untyped)
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def sum(identity=T.unsafe(nil)); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def shellescape(); end

  def shellsplit(); end

  def truncate_bytes(truncate_at, omission: T.unsafe(nil)); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(_); end

  def filter(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Symbol
  def ends_with?(*_); end

  def starts_with?(*_); end
end

class Time
  include ::DateAndTime::Zones
  def acts_like_time?(); end

  def ago(seconds); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def end_of_hour(); end

  def end_of_minute(); end

  def eql_with_coercion(other); end

  def eql_without_coercion(_); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def in(seconds); end

  def minus_with_coercion(other); end

  def minus_with_duration(other); end

  def minus_without_coercion(other); end

  def minus_without_duration(_); end

  def next_day(days=T.unsafe(nil)); end

  def next_month(months=T.unsafe(nil)); end

  def next_year(years=T.unsafe(nil)); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def prev_day(days=T.unsafe(nil)); end

  def prev_month(months=T.unsafe(nil)); end

  def prev_year(years=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def sec_fraction(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def to_default_s(); end
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Time
  def self.===(other); end

  def self.at_with_coercion(*args); end

  def self.at_without_coercion(*_); end

  def self.days_in_month(month, year=T.unsafe(nil)); end

  def self.days_in_year(year=T.unsafe(nil)); end

  def self.find_zone(time_zone); end

  def self.find_zone!(time_zone); end

  def self.rfc3339(str); end

  def self.use_zone(time_zone); end

  def self.zone_default(); end

  def self.zone_default=(zone_default); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.new(*events); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

class UnboundMethod
  def bind_call(*_); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
  def self.[](_); end

  def self.[]=(_, _1); end
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
