# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/activesupport/all/activesupport.rbi
#
# activesupport-5.2.3
class Array
  def blank?; end
  def extract_options!; end
  def fifth; end
  def forty_two; end
  def fourth; end
  def from(position); end
  def second; end
  def second_to_last; end
  def self.try_convert(arg0); end
  def third; end
  def third_to_last; end
  def to(position); end
  def without(*elements); end
end
class Regexp
  def multiline?; end
end
class Hash
  def _deep_transform_keys_in_object!(object, &block); end
  def _deep_transform_keys_in_object(object, &block); end
  def assert_valid_keys(*valid_keys); end
  def blank?; end
  def deep_merge!(other_hash, &block); end
  def deep_merge(other_hash, &block); end
  def deep_stringify_keys!; end
  def deep_stringify_keys; end
  def deep_symbolize_keys!; end
  def deep_symbolize_keys; end
  def deep_transform_keys!(&block); end
  def deep_transform_keys(&block); end
  def except!(*keys); end
  def except(*keys); end
  def extract!(*keys); end
  def extractable_options?; end
  def slice!(*keys); end
  def stringify_keys!; end
  def stringify_keys; end
  def symbolize_keys!; end
  def symbolize_keys; end
  def to_options!; end
  def to_options; end
end
module ActiveSupport
  def self.eager_load!; end
  def self.gem_version; end
  def self.test_order; end
  def self.test_order=(obj); end
  def self.to_time_preserves_timezone; end
  def self.to_time_preserves_timezone=(value); end
  def self.version; end
  def test_order; end
  def test_order=(obj); end
  extend ActiveSupport::Autoload
  extend ActiveSupport::LazyLoadHooks
end
module ActiveSupport::LazyLoadHooks
  def execute_hook(name, base, options, block); end
  def on_load(name, options = nil, &block); end
  def run_load_hooks(name, base = nil); end
  def self.extended(base); end
  def with_execution_control(name, block, once); end
end
module Kernel
  def class_eval(*args, &block); end
end
class Module
  def alias_attribute(new_name, old_name); end
  def anonymous?; end
  def attr_internal(*attrs); end
  def attr_internal_accessor(*attrs); end
  def attr_internal_define(attr_name, type); end
  def attr_internal_ivar_name(attr); end
  def attr_internal_reader(*attrs); end
  def attr_internal_writer(*attrs); end
  def cattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil, &blk); end
  def cattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil); end
  def cattr_writer(*syms, instance_writer: nil, instance_accessor: nil, default: nil); end
  def delegate(*methods, to: nil, prefix: nil, allow_nil: nil); end
  def delegate_missing_to(target); end
  def deprecate(*method_names); end
  def mattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil, &blk); end
  def mattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil); end
  def mattr_writer(*syms, instance_writer: nil, instance_accessor: nil, default: nil); end
  def method_visibility(method); end
  def parent; end
  def parent_name; end
  def parents; end
  def reachable?(*args, &block); end
  def reachable_with_deprecation?(*args, &block); end
  def reachable_without_deprecation?; end
  def redefine_method(method, &block); end
  def redefine_singleton_method(method, &block); end
  def remove_possible_method(method); end
  def remove_possible_singleton_method(method); end
  def self.attr_internal_naming_format; end
  def self.attr_internal_naming_format=(arg0); end
  def silence_redefinition_of_method(method); end
  def thread_cattr_accessor(*syms); end
  def thread_cattr_reader(*syms); end
  def thread_cattr_writer(*syms); end
  def thread_mattr_accessor(*syms); end
  def thread_mattr_reader(*syms); end
  def thread_mattr_writer(*syms); end
  include Module::Concerning
end
class Module::DelegationError < NoMethodError
end
class ActiveSupport::Deprecation
  def self.allocate; end
  def self.behavior(*args, &block); end
  def self.behavior=(arg); end
  def self.debug(*args, &block); end
  def self.debug=(arg); end
  def self.deprecate_methods(*args, &block); end
  def self.deprecation_horizon(*args, &block); end
  def self.deprecation_horizon=(arg); end
  def self.deprecation_warning(deprecated_method_name, message = nil, caller_backtrace = nil); end
  def self.gem_name(*args, &block); end
  def self.gem_name=(arg); end
  def self.initialize(*args, &block); end
  def self.instance; end
  def self.new(*arg0); end
  def self.silence(*args, &block); end
  def self.silenced(*args, &block); end
  def self.silenced=(arg); end
  def self.warn(message = nil, callstack = nil); end
  extend ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend Singleton::SingletonClassMethods
  include ActiveSupport::Deprecation::Behavior
  include ActiveSupport::Deprecation::InstanceDelegator
  include ActiveSupport::Deprecation::MethodWrapper
  include ActiveSupport::Deprecation::Reporting
  include Singleton
end
module ActiveSupport::Deprecation::InstanceDelegator
  def self.included(base); end
end
module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end
  def method_added(method_name); end
end
module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def deprecation_warning(deprecated_method_name, message = nil, caller_backtrace = nil); end
  def warn(message = nil, callstack = nil); end
end
module ActiveSupport::Notifications
  def self.instrument(name, payload = nil); end
  def self.instrumenter; end
  def self.notifier; end
  def self.notifier=(arg0); end
  def self.publish(name, *args); end
  def self.subscribe(*args, &block); end
  def self.subscribed(callback, *args, &block); end
  def self.unsubscribe(subscriber_or_name); end
end
class ActiveSupport::Notifications::Instrumenter
  def finish(name, payload); end
  def finish_with_state(listeners_state, name, payload); end
  def id; end
  def initialize(notifier); end
  def instrument(name, payload = nil); end
  def start(name, payload); end
  def unique_id; end
end
class ActiveSupport::Notifications::Event
  def <<(event); end
  def children; end
  def duration; end
  def end; end
  def end=(arg0); end
  def initialize(name, start, ending, transaction_id, payload); end
  def name; end
  def parent_of?(event); end
  def payload; end
  def time; end
  def transaction_id; end
end
class ActiveSupport::Notifications::Fanout
  def finish(name, id, payload, listeners = nil); end
  def initialize; end
  def listeners_for(name); end
  def listening?(name); end
  def lock; end
  def locked?; end
  def publish(name, *args); end
  def start(name, id, payload); end
  def subscribe(pattern = nil, block = nil); end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
  def unsubscribe(subscriber_or_name); end
  def wait; end
  include Mutex_m
end
module ActiveSupport::Notifications::Fanout::Subscribers
  def self.new(pattern, listener); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end
  def initialize(pattern, delegate); end
  def matches?(name); end
  def publish(name, *args); end
  def start(name, id, payload); end
  def subscribed_to?(name); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Timed < ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end
  def publish(name, *args); end
  def start(name, id, payload); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def finish(name, id, payload); end
  def initialize(delegate); end
  def matches?(arg0); end
  def publish(name, *args); end
  def start(name, id, payload); end
  def subscribed_to?(name); end
end
module ActiveSupport::PerThreadRegistry
  def instance; end
  def method_missing(name, *args, &block); end
  def self.extended(object); end
end
class ActiveSupport::Notifications::InstrumentationRegistry
  def initialize; end
  def instrumenter_for(notifier); end
  extend ActiveSupport::PerThreadRegistry
end
class ActiveSupport::DeprecationException < StandardError
end
module ActiveSupport::Deprecation::Behavior
  def arity_coerce(behavior); end
  def behavior; end
  def behavior=(behavior); end
  def debug; end
  def debug=(arg0); end
end
module ActiveSupport::Deprecation::Reporting
  def _extract_callstack(callstack); end
  def deprecated_method_warning(method_name, message = nil); end
  def deprecation_caller_message(callstack); end
  def deprecation_message(callstack, message = nil); end
  def deprecation_warning(deprecated_method_name, message = nil, caller_backtrace = nil); end
  def extract_callstack(callstack); end
  def gem_name; end
  def gem_name=(arg0); end
  def ignored_callstack(path); end
  def silence; end
  def silenced; end
  def silenced=(arg0); end
  def warn(message = nil, callstack = nil); end
end
module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end
module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end
class ActiveSupport::Deprecation::DeprecationProxy
  def inspect; end
  def method_missing(called, *args, &block); end
  def self.new(*args, &block); end
end
class ActiveSupport::Deprecation::DeprecatedObjectProxy < ActiveSupport::Deprecation::DeprecationProxy
  def initialize(object, message, deprecator = nil); end
  def target; end
  def warn(callstack, called, args); end
end
class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy < ActiveSupport::Deprecation::DeprecationProxy
  def initialize(instance, method, var = nil, deprecator = nil); end
  def target; end
  def warn(callstack, called, args); end
end
class ActiveSupport::Deprecation::DeprecatedConstantProxy < ActiveSupport::Deprecation::DeprecationProxy
  def class; end
  def initialize(old_const, new_const, deprecator = nil, message: nil); end
  def target; end
  def warn(callstack, called, args); end
end
module ActiveSupport::Inflector
  def apply_inflections(word, rules, locale = nil); end
  def camelize(term, uppercase_first_letter = nil); end
  def classify(table_name); end
  def const_regexp(camel_cased_word); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def deconstantize(path); end
  def demodulize(path); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = nil); end
  def humanize(lower_case_and_underscored_word, capitalize: nil, keep_id_suffix: nil); end
  def inflections(locale = nil); end
  def ordinal(number); end
  def ordinalize(number); end
  def parameterize(string, separator: nil, preserve_case: nil); end
  def pluralize(word, locale = nil); end
  def safe_constantize(camel_cased_word); end
  def singularize(word, locale = nil); end
  def tableize(class_name); end
  def titleize(word, keep_id_suffix: nil); end
  def transliterate(string, replacement = nil); end
  def underscore(camel_cased_word); end
  def upcase_first(string); end
  extend ActiveSupport::Inflector
  extend ActiveSupport::Inflector
end
class ActiveSupport::Inflector::Inflections
  def acronym(word); end
  def acronym_regex(*args, &block); end
  def acronym_regex_with_deprecation(*args, &block); end
  def acronym_regex_without_deprecation; end
  def acronyms; end
  def acronyms_camelize_regex; end
  def acronyms_underscore_regex; end
  def clear(scope = nil); end
  def define_acronym_regex_patterns; end
  def human(rule, replacement); end
  def humans; end
  def initialize; end
  def initialize_dup(orig); end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def self.instance(locale = nil); end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end
end
class ActiveSupport::Inflector::Inflections::Uncountables < Array
  def <<(*word); end
  def add(words); end
  def delete(entry); end
  def initialize; end
  def to_regex(string); end
  def uncountable?(str); end
end
module ActiveSupport::Autoload
  def autoload(const_name, path = nil); end
  def autoload_at(path); end
  def autoload_under(path); end
  def autoloads; end
  def eager_autoload; end
  def eager_load!; end
  def self.extended(base); end
end
module ActiveSupport::VERSION
end
module ActiveSupport::Concern
  def append_features(base); end
  def class_methods(&class_methods_module_definition); end
  def included(base = nil, &block); end
  def self.extended(base); end
end
class ActiveSupport::Concern::MultipleIncludedBlocks < StandardError
  def initialize; end
end
module LoggerSilence
  def silence(temporary_level = nil); end
  extend ActiveSupport::Concern
end
module ActiveSupport::LoggerThreadSafeLevel
  def after_initialize; end
  def level; end
  def local_level; end
  def local_level=(level); end
  def local_log_id; end
  extend ActiveSupport::Concern
end
class ActiveSupport::Logger < Logger
  def add(severity, message = nil, progname = nil, &block); end
  def debug?; end
  def error?; end
  def fatal?; end
  def info?; end
  def initialize(*args); end
  def self.broadcast(logger); end
  def self.logger_outputs_to?(logger, *sources); end
  def self.silencer; end
  def self.silencer=(obj); end
  def silencer; end
  def silencer=(obj); end
  def unknown?; end
  def warn?; end
  include ActiveSupport::LoggerThreadSafeLevel
  include LoggerSilence
end
class ActiveSupport::Logger::SimpleFormatter < Logger::Formatter
  def call(severity, timestamp, progname, msg); end
end
module DateAndTime
end
module DateAndTime::Compatibility
  def preserve_timezone; end
  def self.preserve_timezone; end
  def self.preserve_timezone=(obj); end
end
class Object < BasicObject
  def acts_like?(duck); end
  def blank?; end
  def html_safe?; end
  def in?(another_object); end
  def presence; end
  def presence_in(another_object); end
  def present?; end
  def with_options(options, &block); end
  include ActiveSupport::Tryable
end
class NilClass
  def blank?; end
  def try!(*args); end
  def try(*args); end
end
class FalseClass
  def blank?; end
end
class TrueClass
  def blank?; end
end
class String
  def at(position); end
  def blank?; end
  def camelcase(first_letter = nil); end
  def camelize(first_letter = nil); end
  def classify; end
  def constantize; end
  def dasherize; end
  def deconstantize; end
  def demodulize; end
  def first(limit = nil); end
  def foreign_key(separate_class_name_and_id_with_underscore = nil); end
  def from(position); end
  def html_safe; end
  def humanize(capitalize: nil, keep_id_suffix: nil); end
  def is_utf8?; end
  def last(limit = nil); end
  def mb_chars; end
  def parameterize(separator: nil, preserve_case: nil); end
  def pluralize(count = nil, locale = nil); end
  def remove!(*patterns); end
  def remove(*patterns); end
  def safe_constantize; end
  def singularize(locale = nil); end
  def squish!; end
  def squish; end
  def tableize; end
  def titlecase(keep_id_suffix: nil); end
  def titleize(keep_id_suffix: nil); end
  def to(position); end
  def truncate(truncate_at, options = nil); end
  def truncate_words(words_count, options = nil); end
  def underscore; end
  def upcase_first; end
end
class Numeric
  def blank?; end
  def html_safe?; end
end
class Time
  def blank?; end
end
class Class < Module
  def class_attribute(*attrs); end
end
module ActiveSupport::Multibyte
  def self.proxy_class; end
  def self.proxy_class=(klass); end
end
module ActiveSupport::Multibyte::Unicode
  def apply_mapping(string, mapping); end
  def compose(codepoints); end
  def database; end
  def decompose(type, codepoints); end
  def default_normalization_form; end
  def default_normalization_form=(arg0); end
  def downcase(string); end
  def in_char_class?(codepoint, classes); end
  def normalize(string, form = nil); end
  def pack_graphemes(unpacked); end
  def recode_windows1252_chars(string); end
  def reorder_characters(codepoints); end
  def swapcase(string); end
  def tidy_bytes(string, force = nil); end
  def unpack_graphemes(string); end
  def upcase(string); end
  extend ActiveSupport::Multibyte::Unicode
end
class ActiveSupport::Multibyte::Unicode::Codepoint
  def code; end
  def code=(arg0); end
  def combining_class; end
  def combining_class=(arg0); end
  def decomp_mapping; end
  def decomp_mapping=(arg0); end
  def decomp_type; end
  def decomp_type=(arg0); end
  def initialize; end
  def lowercase_mapping; end
  def lowercase_mapping=(arg0); end
  def swapcase_mapping; end
  def uppercase_mapping; end
  def uppercase_mapping=(arg0); end
end
class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def boundary; end
  def boundary=(arg0); end
  def codepoints; end
  def codepoints=(arg0); end
  def composition_exclusion; end
  def composition_exclusion=(arg0); end
  def composition_map; end
  def composition_map=(arg0); end
  def cp1252; end
  def cp1252=(arg0); end
  def initialize; end
  def load; end
  def self.dirname; end
  def self.filename; end
end
class ERB
end
module ERB::Util
  def html_escape_once(s); end
  def json_escape(s); end
  def self.html_escape_once(s); end
  def self.json_escape(s); end
  def self.unwrapped_html_escape(s); end
  def unwrapped_html_escape(s); end
end
class ActiveSupport::SafeBuffer < String
  def %(args); end
  def +(other); end
  def <<(value); end
  def [](*args); end
  def capitalize!(*args); end
  def capitalize(*args, &block); end
  def chomp!(*args); end
  def chomp(*args, &block); end
  def chop!(*args); end
  def chop(*args, &block); end
  def clone_empty; end
  def concat(value); end
  def delete!(*args); end
  def delete(*args, &block); end
  def downcase!(*args); end
  def downcase(*args, &block); end
  def encode_with(coder); end
  def gsub!(*args); end
  def gsub(*args, &block); end
  def html_escape_interpolated_argument(arg); end
  def html_safe?; end
  def initialize(str = nil); end
  def initialize_copy(other); end
  def lstrip!(*args); end
  def lstrip(*args, &block); end
  def next!(*args); end
  def next(*args, &block); end
  def original_concat(*arg0); end
  def prepend(value); end
  def reverse!(*args); end
  def reverse(*args, &block); end
  def rstrip!(*args); end
  def rstrip(*args, &block); end
  def safe_concat(value); end
  def slice!(*args); end
  def slice(*args, &block); end
  def squeeze!(*args); end
  def squeeze(*args, &block); end
  def strip!(*args); end
  def strip(*args, &block); end
  def sub!(*args); end
  def sub(*args, &block); end
  def succ!(*args); end
  def succ(*args, &block); end
  def swapcase!(*args); end
  def swapcase(*args, &block); end
  def to_param; end
  def to_s; end
  def tr!(*args); end
  def tr(*args, &block); end
  def tr_s!(*args); end
  def tr_s(*args, &block); end
  def upcase!(*args); end
  def upcase(*args, &block); end
end
class ActiveSupport::SafeBuffer::SafeConcatError < StandardError
  def initialize; end
end
module Benchmark
  def self.ms; end
end
module ActiveSupport::Benchmarkable
  def benchmark(message = nil, options = nil); end
end
module Enumerable
  def _original_sum_with_required_identity(*arg0); end
  def exclude?(object); end
  def index_by; end
  def many?; end
  def pluck(*keys); end
  def without(*elements); end
end
class Range
  def sum(identity = nil); end
end
module ActiveSupport::Tryable
  def try!(*a, &b); end
  def try(*a, &b); end
end
class Delegator < BasicObject
  include ActiveSupport::Tryable
end
module DateAndTime::Zones
  def in_time_zone(zone = nil); end
  def time_with_zone(time, zone); end
end
class Date
  def default_inspect; end
  def readable_inspect; end
  def to_default_s; end
  def to_formatted_s(format = nil); end
  include DateAndTime::Zones
end
class ActiveSupport::OptionMerger
  def initialize(context, options); end
  def method_missing(method, *arguments, &block); end
end
module Module::Concerning
  def concern(topic, &module_definition); end
  def concerning(topic, &block); end
end
module ActiveSupport::NumberHelper
  def number_to_currency(number, options = nil); end
  def number_to_delimited(number, options = nil); end
  def number_to_human(number, options = nil); end
  def number_to_human_size(number, options = nil); end
  def number_to_percentage(number, options = nil); end
  def number_to_phone(number, options = nil); end
  def number_to_rounded(number, options = nil); end
  extend ActiveSupport::Autoload
  extend ActiveSupport::NumberHelper
end
